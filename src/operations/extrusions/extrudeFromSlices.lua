-- ROBLOX NOTE: no upstream

local LuauPolyfill = require("@Packages/LuauPolyfill")
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local mat4 = require("../../maths/mat4")
local geom2 = require("../../geometries/geom2")
local geom3 = require("../../geometries/geom3")
local poly3 = require("../../geometries/poly3")
local slice = require("./slice")
local repairSlice = require("./slice/repair")
local extrudeWalls = require("./extrudeWalls")
local function defaultCallback(progress, index, base)
	local baseSlice = nil
	if Boolean.toJSBoolean(geom2.isA(base)) then
		baseSlice = slice.fromSides(geom2.toSides(base))
	end
	if Boolean.toJSBoolean(poly3.isA(base)) then
		baseSlice = slice.fromPoints(poly3.toPoints(base))
	end
	return if progress == 0 or progress == 1
		then slice.transform(mat4.fromTranslation(mat4.create(), { 0, 0, progress }), baseSlice)
		else nil
end
--[[*
 * Extrude a solid from the slices as returned by the callback function.
 * @see slice
 *
 * @param {Object} options - options for extrude
 * @param {Integer} [options.numberOfSlices=2] the number of slices to be generated by the callback
 * @param {Boolean} [options.capStart=true] the solid should have a cap at the start
 * @param {Boolean} [options.capEnd=true] the solid should have a cap at the end
 * @param {Boolean} [options.close=false] the solid should have a closing section between start and end
 * @param {Boolean} [options.repair=true] - repair gaps in the geometry
 * @param {Function} [options.callback] the callback function that generates each slice
 * @param {Object} base - the base object which is used to create slices (see the example for callback information)
 * @return {geom3} the extruded shape
 * @alias module:modeling/extrusions.extrudeFromSlices
 *
 * @example
 * // Parameters:
 * //   progress : the percent complete [0..1]
 * //   index : the index of the current slice [0..numberOfSlices - 1]
 * //   base : the base object as given
 * // Return Value:
 * //   slice or null (to skip)
 * const callback = (progress, index, base) => {
 *   ...
 *   return slice
 * }
 ]]
local function extrudeFromSlices(options, base)
	local defaults = {
		numberOfSlices = 2,
		capStart = true,
		capEnd = true,
		close = false,
		repair = true,
		callback = defaultCallback,
	}
	local numberOfSlices, capStart, capEnd, close, repair, generate
	do
		local ref = Object.assign({}, defaults, options)
		numberOfSlices, capStart, capEnd, close, repair, generate =
			ref.numberOfSlices, ref.capStart, ref.capEnd, ref.close, ref.repair, ref.callback
	end
	if
		numberOfSlices
		< 2 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
	then
		error(Error.new("numberOfSlices must be 2 or more"))
	end -- Repair gaps in the base slice
	if Boolean.toJSBoolean(repair) then
		-- note: base must be a slice, if base is geom2 this doesn't repair
		base = repairSlice(base)
	end
	local sMax = numberOfSlices - 1
	local startSlice = nil
	local endSlice = nil
	local prevSlice = nil
	local polygons = {}
	do
		local s = 0
		while
			s
			< numberOfSlices --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
		do
			-- invoke the callback function to get the next slice
			-- NOTE: callback can return null to skip the slice
			local currentSlice = generate(s / sMax, s, base)
			if Boolean.toJSBoolean(currentSlice) then
				if not Boolean.toJSBoolean(slice.isA(currentSlice)) then
					error(Error.new("the callback function must return slice objects"))
				end
				local edges = slice.toEdges(currentSlice)
				if #edges == 0 then
					error(Error.new("the callback function must return slices with one or more edges"))
				end
				if Boolean.toJSBoolean(prevSlice) then
					polygons = Array.concat(polygons, extrudeWalls(prevSlice, currentSlice)) --[[ ROBLOX CHECK: check if 'polygons' is an Array ]]
				end -- save start and end slices for caps if necessary
				if s == 0 then
					startSlice = currentSlice
				end
				if s == numberOfSlices - 1 then
					endSlice = currentSlice
				end
				prevSlice = currentSlice
			end
			s += 1
		end
	end
	if Boolean.toJSBoolean(capEnd) then
		-- create a cap at the end
		local endPolygons = slice.toPolygons(endSlice)
		polygons = Array.concat(polygons, endPolygons) --[[ ROBLOX CHECK: check if 'polygons' is an Array ]]
	end
	if Boolean.toJSBoolean(capStart) then
		-- create a cap at the start
		local startPolygons = Array.map(slice.toPolygons(startSlice), poly3.invert) --[[ ROBLOX CHECK: check if 'slice.toPolygons(startSlice)' is an Array ]]
		polygons = Array.concat(polygons, startPolygons) --[[ ROBLOX CHECK: check if 'polygons' is an Array ]]
	end
	if not Boolean.toJSBoolean(capStart) and not Boolean.toJSBoolean(capEnd) then
		-- create walls between end and start slices
		if
			Boolean.toJSBoolean(
				if Boolean.toJSBoolean(close)
					then not Boolean.toJSBoolean(slice.equals(endSlice, startSlice))
					else close
			)
		then
			polygons = Array.concat(polygons, extrudeWalls(endSlice, startSlice)) --[[ ROBLOX CHECK: check if 'polygons' is an Array ]]
		end
	end
	return geom3.create(polygons)
end
return extrudeFromSlices
